import os
import sys
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad

filename = sys.argv[1]
key = b'\xa5\x9b\x12:\x0ce\xc8\x01\x99\x1cP\x98\xf2\x10)\x84\x9cz\xef\xba\x92\xbc\x8e\xd3\x9c,$\xd4\xa7/DH'

STUB = '''
import os
import sys
from Crypto.Cipher import AES
import subprocess
from Crypto.Util.Padding import unpad

def decrypt():
    chunksize = AES.block_size*1024
    outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "decrypted"+os.path.basename(filename))

    with open(filename, 'rb') as infile:
        filesize = int(infile.read(16).decode('utf-8'))
        IV = infile.read(16)
        key = infile.read(32)
        filesizeSTUB = int(infile.read(16).decode('utf-8'))
        stub = infile.read(filesizeSTUB)

        decryptor = AES.new(key, AES.MODE_CBC, IV)

        with open(outputFile, 'wb') as outfile:
            while True:
                chunk = infile.read()

                if len(chunk) == 0:
                    break
                
                decrypted_chunk = decryptor.decrypt(chunk)
                unpadded_chunk = unpad(decrypted_chunk, AES.block_size)
                outfile.write(unpadded_chunk)

                # outfile.write(decryptor.decrypt(chunk))

            outfile.truncate(filesize)

decrypt()

decrypted_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "decrypted"+os.path.basename(filename))
subprocess.run(["start", "", decrypted_file_path], shell=True) #opens new cmd and runs file
'''
#padding for stub
STUB = STUB.ljust((len(STUB) // 16 + 1) * 16)
filesizeSTUB = str(len(STUB)).zfill(16)
print(filesizeSTUB)
print(filesizeSTUB.encode('utf-8'))

def oldEncrypt(key, filename):
    chunksize = AES.block_size*1024
    # outputFile = "(enc)"+filename
    outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "(enc)"+os.path.basename(rf"{filename}"))
    filesize = str(os.path.getsize(filename)).zfill(16)
    IV = Random.new().read(16)

    encryptor = AES.new(key, AES.MODE_CBC, IV)

    with open(filename, 'rb') as infile:#rb means read in binary
        with open(outputFile, 'wb') as outfile:#wb means write in the binary mode
            outfile.write(filesize.encode('utf-8'))
            outfile.write(IV)
            outfile.write(filesizeSTUB.encode('utf-8'))
            outfile.write(STUB.encode('utf-8'))

            while True:
                chunk = infile.read(chunksize)

                if len(chunk) == 0:
                    break
                else:
                    padded_chunk = pad(chunk, AES.block_size)
                    outfile.write(encryptor.encrypt(padded_chunk))

                # outfile.write(encryptor.encrypt(chunk))

def secondEncrypt(key, filename):
    chunksize = AES.block_size * 1024
    # outputFile = "(enc)"+filename
    outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "(enc)"+os.path.basename(rf"{filename}"))
    filesize = str(os.path.getsize(filename)).zfill(16)
    IV = Random.new().read(16)

    # pad the stub size as well
    padded_stub_size = len(STUB).to_bytes(16, byteorder='big')
    padded_stub_size += b'\0' * (16 - len(padded_stub_size))


    encryptor = AES.new(key, AES.MODE_CBC, IV)

    with open(filename, 'rb') as infile:
        with open(outputFile, 'wb') as outfile:
            outfile.write(filesize.encode('utf-8'))
            outfile.write(IV)
            outfile.write(padded_stub_size)  # write the padded stub size
            # outfile.write(filesizeSTUB.encode('utf-8'))
            outfile.write(STUB.encode('utf-8').ljust(len(padded_stub_size)))  # pad the stub and write it
            # outfile.write(STUB.encode('utf-8'))

            while True:
                chunk = infile.read(chunksize)

                if len(chunk) == 0:
                    break
                else:
                    padded_chunk = pad(chunk, AES.block_size, style='pkcs7')
                    outfile.write(encryptor.encrypt(padded_chunk))

                outfile.write(encryptor.encrypt(chunk))

def encrypt(key, filename):
    chunksize = AES.block_size * 1024
    # outputFile = "(enc)"+filename
    outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "enc"+os.path.basename(filename))
    filesize = str(os.path.getsize(filename)).zfill(16)
    print('filesize ', filesize)
    IV = Random.new().read(16)

    encryptor = AES.new(key, AES.MODE_CBC, IV)

    with open(filename, 'rb') as infile:
        with open(outputFile, 'wb') as outfile:
            outfile.write(filesize.encode('utf-8'))
            outfile.write(IV)
            outfile.write(key)
            outfile.write(filesizeSTUB.encode('utf-8'))
            outfile.write(STUB.encode('utf-8'))

            while True:
                chunk = infile.read()

                if len(chunk) == 0:
                    break

                else:
                    padded_chunk = pad(chunk, AES.block_size)
                    outfile.write(encryptor.encrypt(padded_chunk))

                # outfile.write(encryptor.encrypt(chunk))


encrypt(key, filename)
outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "enc"+os.path.basename(filename))
print(os.path.getsize(outputFile))