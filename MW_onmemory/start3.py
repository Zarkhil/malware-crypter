# import pefile
# import ctypes

# # Load the executable into memory
# executable_path = r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\calculator.exe'
# pe = pefile.PE(executable_path)

# # Get the address of the entry point
# entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint

# # Get a handle to the process heap
# process_heap = ctypes.windll.kernel32.GetProcessHeap()

# # Allocate memory in the process heap
# allocation_base = ctypes.windll.kernel32.HeapAlloc(process_heap, 0, len(pe.get_memory_mapped_image()))

# # Write the executable image to the allocated memory
# ctypes.windll.kernel32.RtlMoveMemory(allocation_base, pe.get_memory_mapped_image(), len(pe.get_memory_mapped_image()))

# # Call the entry point
# ctypes.windll.kernel32.CreateThread(None, 0, entry_point, allocation_base, 0, None)

import pefile
import ctypes

# Load the executable into memory
pe = pefile.PE(r'C:\Users\John Emro\Documents\GitHub\malware-crypter\MW_onmemory\calculator.exe')
executable = pe.get_memory_mapped_image()
buffer_size = len(executable)
allocation_base = ctypes.windll.kernel32.VirtualAlloc(None, buffer_size, 0x3000, 0x40)

if not allocation_base:
    raise ctypes.WinError()

# Copy the executable into the allocated memory
ctypes.memmove(allocation_base, executable, buffer_size)

# Get a function pointer to the entry point of the executable
entry_point = ctypes.cast(allocation_base + pe.OPTIONAL_HEADER.AddressOfEntryPoint, ctypes.CFUNCTYPE(None))

# Call the entry point
entry_point()
